import React, { useState, useEffect } from "react";
import { useHistory, useParams } from 'react-router-dom';
import { addDeck, updateDeck, getDeckById } from "../../modules/deckManager";
import Swal from "sweetalert2";
import "./UserDeck.css"
import newDeckLogo from "../../images/newDeckLogo.PNG";
import editDeckLogo from "../../images/editDeckLogo.PNG";


const DeckForm = () => {

    const [deck, setDeck] = useState({});

    const history = useHistory();
    const { deckId } = useParams();

    useEffect(() => {
        if (deckId) {
            getDeckById(deckId)
            .then(deck => {
                setDeck(deck) // pre-populate deck state/obj with current values when editing a deck if there is a deckId param in route
            })
        } 
    }, []);

    // When a field changes, update state. The return will re-render and display based on the values in state:
    const handleInputChange = (event) => {
        /* When changing a state object or array,
        create a copy, make changes, and then set state.*/
        const newDeck = { ...deck }
        /* Dynamically set the properties of the deck obj to the new corresponding values
        using object bracket notation. */
        newDeck[event.target.id] = event.target.value
        // update state
        setDeck(newDeck)
    };

    const saveNewDeck = () => {
          const newDeck = {
            // deck.id and deck.userProfileId are generated by the back-end when deck obj is persisted/saved to db
            title: deck.title,
            details: deck.details
          }
          // Invoke addDeck passing the new deck object as an argument
          // Once complete, change the url and display the user deck list
          addDeck(newDeck)
            .then(() => history.push("/myDecks"));
    };

    const saveEditDeck = () => {
        updateDeck({
            id: deck.id,
            userProfileId: deck.userProfileId,
            title: deck.title,
            details: deck.details
        })
        .then(() => history.push(`/myDecks`))
    };

    const handleClickSaveDeck = () => {
        const title = deck.title
        const details = deck.details

        if (typeof title === "undefined" || typeof details === "undefined") {
            Swal.fire({
            title: "Please provide values for both input fields. ðŸ‘‡",
            icon: "info",
            confirmButtonColor: "#20B2AA"
            });
        } else {      
          if (deckId) {
              //PUT - update
              if (title === "" || details === "") {
                Swal.fire({
                    title: "Cannot save an empty deck! Please provide values for both input fields. ðŸ‘‡",
                    icon: "info",
                    confirmButtonColor: "#20B2AA"
                });
              } else {
                saveEditDeck()
                Swal.fire({
                    title: "Deck Updated! ðŸ˜Š",
                    icon: "info",
                    confirmButtonColor: "#20B2AA"
                });
              }             
          } else {
              saveNewDeck()
              Swal.fire({
                title: "New Deck Created! ðŸ˜Š",
                icon: "info",
                confirmButtonColor: "#20B2AA"
              });
          }
        };
    };

    // Reroute to My Decks page on cancel:
    const handleClickCancel = () => {
    // window.history.back();
        history.push("/myDecks");
    };

    return (
        <div>
            <div>
                {
                    deckId ? <img className="editDeckLogo" src={editDeckLogo} alt="Edit Deck" /> 
                        : 
                            <img className="newDeckLogo" src={newDeckLogo} alt="New Deck" />
                }  
            </div>         
            <div className="field deckForm">
                <h1 className="deckForm__title">{ deckId ? "~Update Deck~" : "~Create Deck~" }</h1>
                <label className="label deckFormLabel">Title:</label>
                <div className="control">
                    <input className="input deckFormInput" type="text" id="title" value={deck.title} defaultValue={deck.title} onChange={(event) => {handleInputChange(event)}} required autoFocus placeholder="Give a marvelous title..." />
                    <span className="icon is-small is-right">
                    <i className="fas fa-check"></i>
                    </span>
                </div>

                <div className="field">
                    <label className="label deckFormLabel">Details:</label>
                    <div className="control">
                        <textarea className="textarea deckFormInput" id="details" value={deck.details} defaultValue={deck.details} onChange={(event) => {handleInputChange(event)}} required autoFocus placeholder="Give marvelous details..."></textarea>
                    </div>
                </div>

                <div className="field is-grouped">
                    <div className="control">
                        <button className="button is-dark is-outlined is-rounded cancelDeckBut" onClick={() => {handleClickCancel()}}>Cancel</button>
                    </div>
                    <div className="control">
                        <button className="button is-dark is-outlined is-rounded add-deck-but" onClick={() => {handleClickSaveDeck()}}>{ deckId ? "Save Deck" : "Add Deck" }</button>
                    </div>
                </div>
               
            </div>
        </div>
    );
};


export default DeckForm;